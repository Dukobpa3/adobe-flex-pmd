<?xml version="1.0"?>
<ruleset name="Basic As3 Rules" xmlns="http://pmd.sf.net/ruleset/1.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd"
	xsi:noNamespaceSchemaLocation="http://pmd.sf.net/ruleset_xml_schema.xsd">
	<description>
      The Basic As3 Ruleset contains a collection of good practices which everyone should follow.
  </description>
	<rule class="com.adobe.ac.pmd.rules.maintanability.DynamicClassRule" message="A class must not be dynamic">
		<description>When using dynamic classes, you cannot control how the developer will use your classe. It makes refactoring really difficult.</description>
		<priority>1</priority>
		<example>
   dynamic public class DynamicObject // VIOLATION
   {
   }
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.event.EventMissingCloneFunctionRule"
		message="The clone event must be overiden in a custom event">
		<description>Why do you need to override clone? Well, the clone method creates a copy of your event (or object - whatever object has the clone event; this isn't limited to Event objects). The default clone method inherited by the Event class or whatever class your custom class extends, will return an event object of the type of that class, not your custom event subclass. In the situations where a clone is needed, it is needed to be of the same type of your class, not the class it extends.</description>
		<priority>1</priority>
		<example>
   public class FirstCustomEvent   // VIOLATION - clone method is missing
   {
      public var lala : String;
      
      public function FirstCustomEvent()
      {         
      }
   }
      </example>
	</rule>
	<rule
		class="com.adobe.ac.pmd.rules.event.PublicVariableInCustomEventRule"
		message="No public variables should be inside a custom event. This variable ({0}) is public">
		<description>In order to improve encapsulation in your custom event, it is better not to have public variable in your event. Prefer having read-only attributes, set by the event constructor.</description>
		<priority>3</priority>
		<example>
   public class FirstCustomEvent   
   {
      public var lala : String; // VIOLATION
      
      public function FirstCustomEvent()
      {         
      }
   }      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.style.ConstructorNonEmptyReturnTypeRule"
		message="A constructor should not have a return type">
		<description>Even if this is syntaxically correct, there should not be a return type for a constructor.</description>
		<priority>3</priority>
		<example>
   public class VoidConstructor   
   {
      public function VoidConstructor() : void
      {         
      }      
   }
      </example>
	</rule>
	<rule
		class="com.adobe.ac.pmd.rules.switchrules.SwitchStatementsShouldHaveDefaultRule"
		message="A switch statement does not contain a default statement">
		<description>Switch statements should have a default label in order to detect corner cases.</description>
		<priority>1</priority>
		<example>
   public class Foo 
   {
      public funciton bar() : void 
      {
         var  x : int = 2;
         switch (x) 
         {
            case 2: var j : int = 8;
         }
      }
   }     
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.maintanability.UseOfObjectTypeRule"
		message="Do not use Object class">
		<description>It is a bad practice to use the dynamic class Object. Prefer using strongly typed object, or marker interface in order to avoid silent compilation errors while refactoring</description>
		<priority>1</priority>
		<example>
   public class Foo
   {
      public var bar : Object; // VIOLATION      
   }
      </example>
	</rule>

	<rule class="com.adobe.ac.pmd.rules.switchrules.NestedSwitchRule"
		message="Switch must not be nested">
		<description>As a general practice, switch statement should not be used. Prefer using inheritance. It is even harder to read when siwtch statements are nested.</description>
		<priority>3</priority>
		<example>
      public function foo( a : Number, b : Number ) : void
      {
          switch( a )
          {
             case 1:
                break;
             case 2:                   
                switch ( b ) 
                {
                  case 3 :
                     break;
                  case 4 :
                     break;
                }
                break;                     
          }
      }
      </example>
	</rule>

	<rule class="com.adobe.ac.pmd.rules.maintanability.ArrayFieldWithNoArrayElementTypeRule"
		message="ArrayElementType metadata is not specified for this array-type field ({0})">
		<description>
      </description>
		<priority>3</priority>
		<example>
   public class ArrayVO {
      public var items:Array; //VIOLATION

      [ArrayElementType("model.vo.MenuItemVO")]
      public var menuItems : Array;
   }      
      </example>
	</rule>

	<rule class="com.adobe.ac.pmd.rules.maintanability.NonStaticConstantFieldRule"
		message="A constant field should be static ({0})">
		<description>
      </description>
		<priority>1</priority>
		<example>
   public class MyObject {
      public static const MY_STATIC_CONSTANT : String = "myStaticConstant";
      public const MY_NON_STATIC_CONSTANT : String = "myStaticConstant"; // VIOLATION
   }     
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.unused.UnusedParameterRule"
		message="This parameter ({0}) of this function is not used">
		<description>
      </description>
		<priority>1</priority>
		<example>
      public function foo( param1 : Number, param2 : Number, param3 : Number, param4 : Number, param5 : Number ) : void // 4 violations
      {
         var i : int = param1;
      }
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.unused.UnusedLocalVariableRule"
		message="This variable ({0}) is not used">
		<description>
      </description>
		<priority>3</priority>
		<example>
      public function foo() : void
      {
         var i : int = 0;// 1 violation
      }
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.unused.UnusedPrivateMethodRule"
		message="This private method ({0}) does not seem to be used">
		<description>
      </description>
		<priority>1</priority>
		<example>
      </example>
	</rule>
	<rule
		class="com.adobe.ac.pmd.rules.switchrules.TooFewBrancheInSwitchStatementRule"
		message="There are too few branches in this switch statement ({0} minimum, but {1} actual)">
		<description>Switch statements are designed for complex branches, and allow branches to share treatement. Using a switch for only 2 branches is ill advised, as switches are not as easy to understand as if. In this case, it's most likely is a good idea to use a if statement</description>
		<priority>5</priority>
		<properties>
			<property name="minimum">
				<value>3</value>
			</property>
		</properties>
		<example>
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.style.BadFormatLogerRule"
		message="The logger is not correctly formatted, for that reason: {0}">
		<description></description>
		<priority>5</priority>
		<example>
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.performance.AvoidInstanciationInLoopRule"
		message="Instanciating a variable in a loop can be expensive">
		<description></description>
		<priority>3</priority>
		<example>
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.as3.ViewComponentReferencedInModelRule"
		message="A view component should not be referenced in a model class">
		<description></description>
		<priority>3</priority>
		<example>
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.maintanability.UseGenericTypeRule"
		message="Use strongly typed objects instead of *">
		<description></description>
		<priority>1</priority>
		<example>
      </example>
	</rule>
	<rule
		class="com.adobe.ac.pmd.rules.event.ConstructorDispatchingEventRule"
		message="An event is dispatched in a constructor">
		<description>This is pointless, since event listeners cannot be attached to an object before it has been constructed, so nothing can ever hear the event</description>
		<priority>1</priority>
		<example>
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.maintanability.UselessOverridenFunctionRule"
		message="This method is empty. This should be removed ({0})">
		<description>This function is not needed.</description>
		<priority>3</priority>
		<example>
      override protected function createChildren() : void
      {
         super.createChildren();
      }
      </example>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.empty.EmptyCatchStatementRule"
		message="This catch statement is empty">
		<priority>3</priority>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.naming.PropertyHiddenByLocalVariableRule"
		message="A class property is hidden by this local variable ({0})">
		<priority>3</priority>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.maintanability.AvoidProtectedFieldInFinalClassRule"
		message="Protected accessors are useless in a final class. Make it private ({0})">
		<priority>3</priority>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.event.DefaultEventNameRule"
		message="Event name should be set explicitly">
		<priority>3</priority>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.switchrules.IdenticalSwitchCasesRule"
		message="Two switch cases should not identical">
		<priority>1</priority>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.performance.DeeplyNestedIfRule"
		message="Nested if statements are not a good design">
		<priority>3</priority>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.maintanability.TrueFalseConditionRule"
		message="This test contains an hard coded boolean value. You could remove it.">
		<priority>1</priority>
	</rule>
	<rule class="com.adobe.ac.pmd.rules.maintanability.AvoidUsingPublicStaticFieldRule"
	message="If this field was meant to be a constant, make it constant. Otherwise, if it is used as a global variable, you may want to redesign this class.">
		<priority>3</priority>
	</rule>
</ruleset>
